// __BEGIN_LICENSE__
// Copyright (C) 2006-2009 United States Government as represented by
// the Administrator of the National Aeronautics and Space Administration.
// All Rights Reserved.
// __END_LICENSE__


#include <cxxtest/TestSuite.h>

#include <vw/Plate/Blob.h>
#include <vw/Plate/BlobManager.h>
#include <vw/Plate/ProtoBuffers.pb.h>

using namespace std;
using namespace vw;
using namespace vw::platefile;

class TestBlobIO : public CxxTest::TestSuite
{
  boost::shared_array<uint8> m_test_data;
  boost::shared_array<uint8> m_verify_data;
public:

  TestBlobIO() {
    m_test_data = boost::shared_array<uint8>(new uint8[20]);
    for (int i = 0; i < 20; ++i) {
      m_test_data[i] = i;
    }
  }

  void test_write_then_read()
  {
    TileHeader hdr; 
    hdr.set_filetype("tif");
    hdr.set_col(0);
    hdr.set_row(0);
    hdr.set_depth(0);
    unlink("/tmp/foo.blob");

    // First test, creates a new blob file.
    {
      Blob blob("/tmp/foo.blob");
    
      // Write the data to the file.
      int64 offset = blob.write(hdr, m_test_data, 20);

      // Test reading of the data
      boost::shared_array<uint8> m_verify_data = blob.read_data(offset);

      for (int i = 0; i < 20; ++i) 
        TS_ASSERT_EQUALS( m_test_data[i], m_verify_data[i] );

      // Test Reading of the header
      TileHeader hdr2 = blob.read_header<TileHeader>(offset);
      TS_ASSERT_EQUALS(hdr.filetype(), hdr2.filetype());
      TS_ASSERT_EQUALS(hdr.col(), hdr2.col());
      TS_ASSERT_EQUALS(hdr.row(), hdr2.row());
      TS_ASSERT_EQUALS(hdr.depth(), hdr2.depth());
    }

    // Second test, appends to a blob file.
    {
      Blob blob("/tmp/foo.blob");
    
      // Write the data to the file.      
      int64 offset = blob.write(hdr, m_test_data, 20);
      
      // Read it back in.
      boost::shared_array<uint8> m_verify_data = blob.read_data(offset);

      for (int i = 0; i < 20; ++i) 
        TS_ASSERT_EQUALS( m_test_data[i], m_verify_data[i] );
    }
  }

  void test_file_write_read() {

    TileHeader hdr;
    hdr.set_filetype("tif");
    hdr.set_col(0);
    hdr.set_row(0);
    hdr.set_depth(0);

    const char* f1 = "/tmp/foo.blob";
    const char* f2 = "/tmp/foo3.blob";
    unlink(f2);

    Blob blob("/tmp/foo2.blob");
    
    // Do one loop through the blob file, placing f1 into the file,
    // and then reading it back out and saving it as f2.
    int64 offset;
    blob.write_from_file(f1, hdr, offset);
    blob.read_to_file(f2, offset);

    // ----

    // Now, check to make sure it worked!!
    std::ifstream istr1(f1, ios::binary);
    std::ifstream istr2(f2, ios::binary);

    // Check to see if files are the same size
    istr1.seekg (0, std::ios::end);
    istr2.seekg (0, std::ios::end);
    int64 size1 = istr1.tellg();
    int64 size2 = istr2.tellg();
    TS_ASSERT_EQUALS(size1, size2);

    if (size1 == size2) {
      istr1.seekg (0, std::ios::beg);
      istr2.seekg (0, std::ios::beg);
      
      boost::shared_array<char> data1(new char[size1]);
      boost::shared_array<char> data2(new char[size2]);
      
      istr1.read(data1.get(), size1);
      istr2.read(data2.get(), size2);

      for (int i=0; i < size1; ++i) {
        if (data1[i] != data2[i]) {
          TS_FAIL("Write/Read test of blob file failed. Data does not agree between input and output files.");
        }
      }
    }
    
    istr1.close();
    istr2.close();

    unlink(f1);
    unlink(f2);
    unlink("/tmp/foo2.blob");
  }

}; // class TestBlobIO
